# CPU性能篇

### 02 | 基础篇：到底应该怎么理解“平均负载”？

平均负载：单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，和 CPU 使用率并没有直接关系。

- 可运行状态的进程：正在使用 CPU 或者正在等待 CPU 的进程
- 不可中断状态的进程：处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应

例如，使用uptime命令，发现一个单CPU系统上，平均负载分别为1.73，0.60，7.98，则说明过去一分钟平均负载为1.73，高于CPU总数的73%。

##### 平均负载 vs CPU使用率：

首先，两者没有直接关系。例如，CPU密集型进程，两者成正比；而IO密集型，负载很高而CPU使用率则不一定很高。

##### 案例分析：负载升高

1. CPU密集型进程：平均负载升高，CPU使用率升高
2. IO密集型：平均负载升高，CPU使用率变化不明显，而iowait很高
3. 大量进程：平均负载极度升高，进程等待CPU时间很高

##### 一般标准：平均负载低于70%算正常

##### 所用工具: 

1. `stress`: 负载模拟
2. `sysstat`: 查看系统情况，包括`vmstat`, `pidstat`等



### 03-04 | 基础篇：经常说的 CPU 上下文切换是什么意思？

多个进程竞争CPU同样能导致平均负载升高，是因为CPU上下文切换也会消耗CPU资源。

CPU上下文切换：CPU保存当前任务状态(例如寄存器，PC等)，然后加载新任务的过程。

1. 进程上下文切换：系统调用(用户进程，内核进程)，正常调度、时间片强制挂起、资源等待，主动Sleep、按优先级
2. 线程上下文切换：线程是调度的基本单位，而进程则是资源拥有的基本单位。切换分为进程内与进程间
3. 终端上下文切换：对同一个 CPU 来说，中断处理比进程拥有更高的优先级。

##### 如何查看系统上下文切换情况：

1. `vmstat`：重点列，cs(context switch), in(interrupt), r(running or runnable), b(Blocked)
2. `pidstat -w 5`:
   - `cswch`: 自愿上下文切换，因为进程无法获取资源(IO、内存等)而导致的上下文切换
   - `nvcswch`: 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换

##### 案例分析：如何排查上下文切换频率过高

1. `vmstat 1`：粗略查看上下文切换情况，中断情况
2. `pidstat -wt 1`：明确哪些进程上下文切换过快
3. `watch -d cat /proc/interrupts`：观察中断情况。

##### 一般标准：如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的

### 05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？

CPU时间：Linux通过使用事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。即使用节拍数来表示CPU时间

CPU使用率：除了空闲时间外的其他时间占总 CPU 时间的百分比

##### 如何查看：`top`命令，`pidstat`命令

##### 案例分析：

1. 用`ab`命令压测：`ab -c 10 -n 10000 http://10.240.0.5:10000/`
2. 用`per`命令查看调用链，排查出相关代码块：`perf top -g -p 21515`

### 06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？

实战篇，排查CPU使用率过高问题，最终定位为短时exec类程序调用错误，导致CPU资源消耗在此类进程的创建过程中。

##### 排查步骤：

1. 使用`top`命令，观察到CPU的整体使用率很高，而其列表中的进程的CPU使用率均正常
2. 使用`pidstat`查看，也正常。**注：不要武断地工具结果怀疑，要用多个工具交叉验证**
3. 仔细观察`top`界面的进程列表，发现有`php-fpm`大都为`S`，而处于`R`的是名为`stress`的进程。
4. 而根据进程号，用`pidstat`与`ps`命令未能找到它。再次打开top发现该进程已经不见了，因此怀疑要么程序不断重启，要么是短时进程，即通过exec执行的命令。
5. 继续排查，通过`pstress | grep stress`找到`stress`的父进程确实为`php-fpm`，再到`php-fpm`源码中找到了相关代码块
6. 除此之外，使用`perf record -g`与`perf report`能记录一段时间内的性能时间，得到报告方便排查
7. 除此之外，使用`execsnoop`来专门监控进程的`exec()`行为并报告。

##### 总结：碰到常规方案无法解释CPU使用率过高时，首先需联想到是短时进程导致的。

1. 应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。
2. 应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU。

### 07-08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？

##### 进程的状态与解释：

- **R** 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。
- **D** 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
- **Z** 是 Zombie 的缩写，表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
- **S** 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。
- **I**是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。其不会导致负载升高
- **T** 是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。
- **X**是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它

##### 进程组：进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员

##### 会话： 共享同一个控制终端的一个或多个进程组。

##### 案例分析

通过观察`top`，发现负载在升高，cpu使用率正常但是iowati很高，发现有进程处于D状态，说明可能在等待IO。其次僵尸进程也很多。

- 排查iowait过高
  1. 使用`dstat`查看CPU与IO情况，发现大量磁盘读请求
  2. 因此我们找出处于D状态的进程号，使用`pidstat -d -p 4344 1 3`查看，为发现IO。干脆去掉进程号后，发现`app`进程磁盘读很高。明确是`app`进程的问题
  3. 使用`strace -p 6082`查看该进程的调用，发现报错，通过`ps`查看后，发现已经是僵尸进程了。
  4. 常规工具已无法排查，此时拿出perf这种基于事件记录的工具，发现app对此时进程了**直接读**，因此明确了原因

- 排查僵尸进程
  1. 通过`pstree -aps 3084`找到僵尸进程3084的父进程，排查改父进程代码看是否存在未回收子进程的情况。

### 09-10 | 基础篇：怎么理解Linux软中断？

中断：操作系统用来响应硬件设备请求的一种机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。

为了避免中断程序运行时间过长，而影响CPU相应其他中断，将软终端分为上半部与下半部：

- 上半部：直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行
- 下半部：由内核触发，也就是我们常说的软中断，特点是延迟执行。通常以内核线程的方式运行，包括网络收发、定时、调度、RCU 锁等

##### 如何查看

- 查看软中断的运行情况：/proc/softirqs ；
- 查看硬中断的运行情况：/proc/interrupts 。

注：其中TASKLET只运行一次就会结束 ，并且只在调用它的函数所在的 CPU 上运行。

- 查看软中断的内核线程: `ps aux | grep softirq`

##### 案例分析

- 首先觉察命令行卡顿现象，`top`命令观察，似乎一切正常。但是发现软终端进程cpu占用略高有0.3。怀疑软中断可能有异常
- 通过`watch -d cat /proc/softirqs`观察，发现`NET_RX`行中断次数存在迅速升高现象。需排查网络情况
- 通过`sar -n DEV 1`查看网口流量情况，发现`eho0`网口的`rxpck/s`异常地高，需排查该网口
- 通过`tcpdump -i eth0 -n tcp port 80`抓包分析，发现有大量来自`192.168.0.2`的SYN包，因此判定为SYN FLOOD攻击

### 11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？（分析套路指南）

##### CPU 性能指标总结

<img src="https://raw.githubusercontent.com/erenming/image-pool/master/linux-perf/cpu-metrics.png" style="float:left; width:500px;height:300 px" />

##### 指标->工具对照表

<img src="https://raw.githubusercontent.com/erenming/image-pool/master/linux-perf/metrics-tool.png" style="float:left; width:600px;height:500 px" />

##### 工具->指标对照表

<img src="https://raw.githubusercontent.com/erenming/image-pool/master/linux-perf/tool-metrics.png" style="float:left; width:600px;height:500 px" />

##### 分析思路流程指北

<img src="https://raw.githubusercontent.com/erenming/image-pool/master/linux-perf/roadmap.png" style="float:left; width:600px;height:500 px" />

### 12 | 套路篇：CPU 性能优化的几个思路（优化套路指南）

#### 方法论

问题检验法：

- 首先，既然要做性能优化，那要怎么判断它是不是有效呢？特别是优化后，到底能提升多少性能呢？
- 第二，性能问题通常不是独立的，如果有多个性能问题同时发生，你应该先优化哪一个呢？
- 第三，提升性能的方法并不是唯一的，当有多种方法可以选择时，你会选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？

##### 评估优化效果

1. 确定性能的量化指标。
2. 测试优化前的性能指标。
3. 测试优化后的性能指标。

且纬度不要单一，至少是应用和系统两个纬度。例如web应用，应用纬度为**延迟、吞吐量**，系统纬度为**cpu使用率**。

测试指标期间应保持系统应用的隔离性，减少外部干扰。

##### 常见优化方法

1. 应用程序方面：遵循二八原则，排除所有不必要的工作，只保留最核心的逻辑。编译器优化，算法优化，异步处理，多线程代替多进程，缓存
2. 系统方面：CPU绑定，CPU独占，优先级调整，为进程设置资源限制，中断负载均衡

##### 注意：千万避免过早优化

### 13-14|CPU答疑篇

1. perf排查容器类进程时，看不到具体函数？

> 容器的特殊性，找不到对应动态库。可通过以下方式解决。
>
> 1. 在容器内部运行 perf
> 2. 指定符号路径为容器文件系统的路径，使用bindfs绑定
> 3. 在容器外面把分析纪录保存下来，再去容器里查看结果

2. 书籍推荐？

> 《Systems Performance: Enterprise and the Cloud》

##### 金句

理解最基本的原理，再掌握性能分析的思路，然后再逐步深入，探究细节