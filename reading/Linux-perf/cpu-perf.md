# CPU性能篇

### 02 | 基础篇：到底应该怎么理解“平均负载”？

平均负载：单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，和 CPU 使用率并没有直接关系。

- 可运行状态的进程：正在使用 CPU 或者正在等待 CPU 的进程
- 不可中断状态的进程：处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应

例如，使用uptime命令，发现一个单CPU系统上，平均负载分别为1.73，0.60，7.98，则说明过去一分钟平均负载为1.73，高于CPU总数的73%。



平均负载 vs CPU使用率：

首先，两者没有直接关系。例如，CPU密集型进程，两者成正比；而IO密集型，负载很高而CPU使用率则不一定很高。



案例分析：负载升高

1. CPU密集型进程：平均负载升高，CPU使用率升高
2. IO密集型：平均负载升高，CPU使用率变化不明显，而iowait很高
3. 大量进程：平均负载极度升高，进程等待CPU时间很高

一般标准：平均负载低于70%算正常



所用工具: 

1. `stress`: 负载模拟
2. `sysstat`: 查看系统情况，包括`vmstat`, `pidstat`等



### 03-04 | 基础篇：经常说的 CPU 上下文切换是什么意思？

多个进程竞争CPU同样能导致平均负载升高，是因为CPU上下文切换也会消耗CPU资源。

CPU上下文切换：CPU保存当前任务状态(例如寄存器，PC等)，然后加载新任务的过程。

1. 进程上下文切换：系统调用(用户进程，内核进程)，正常调度、时间片强制挂起、资源等待，主动Sleep、按优先级
2. 线程上下文切换：线程是调度的基本单位，而进程则是资源拥有的基本单位。切换分为进程内与进程间
3. 终端上下文切换：对同一个 CPU 来说，中断处理比进程拥有更高的优先级。



如何查看系统上下文切换情况：

1. `vmstat`：重点列，cs(context switch), in(interrupt), r(running or runnable), b(Blocked)
2. `pidstat -w 5`:
   - `cswch`: 自愿上下文切换，因为进程无法获取资源(IO、内存等)而导致的上下文切换
   - `nvcswch`: 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换



案例分析：如何排查上下文切换频率过高

1. `vmstat 1`：粗略查看上下文切换情况，中断情况
2. `pidstat -wt 1`：明确哪些进程上下文切换过快
3. `watch -d cat /proc/interrupts`：观察中断情况。

一般标准：如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的

### 05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？

CPU时间：Linux通过使用事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。即使用节拍数来表示CPU时间

CPU使用率：除了空闲时间外的其他时间占总 CPU 时间的百分比



如何查看：`top`命令，`pidstat`命令

如何排查分析：`perf`命令



案例分析：

1. 用`ab`命令压测：`ab -c 10 -n 10000 http://10.240.0.5:10000/`
2. 用`per`命令查看调用链：`perf top -g -p 21515`

### 06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？

实战篇，排查CPU使用率过高问题，最终定位为短时exec类程序调用错误，导致CPU资源消耗在此类进程的创建过程中。

排查步骤：

1. 使用`top`命令，观察到CPU的整体使用率很高，而其列表中的进程的CPU使用率均正常
2. 使用`pidstat`查看，也正常。**注：不要武断地工具结果怀疑，要用多个工具交叉验证**
3. 仔细观察`top`界面的进程列表，发现有`php-fpm`大都为`S`，而处于`R`的是名为`stress`的进程。
4. 而根据进程号，用`pidstat`与`ps`命令未能找到它。再次打开top发现该进程已经不见了，因此怀疑要么程序不断重启，要么是短时进程，即通过exec执行的命令。
5. 继续排查，通过`pstress | grep stress`找到`stress`的父进程确实为`php-fpm`，再到`php-fpm`源码中找到了相关代码块
6. 除此之外，使用`perf record -g`与`perf report`能记录一段时间内的性能时间，得到报告方便排查
7. 除此之外，使用`execsnoop`来专门监控进程的`exec()`行为并报告。

总结：碰到常规方案无法解释CPU使用率过高时，首先需联想到是短时进程导致的。

1. 应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。
2. 应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU。

